structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN | UMINUS
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

%nonterm  exp of A.exp
        | program of A.exp
        | lValue of A.var
        | seqExp
        | seqExpList
        | callExp of A.exp
        | infixExp of A.exp
        | arrCreate
        | recCreate
        | assignment
        | ifThenElse
        | ifThen
        | whileExp
        | forExp
        | letExp
        | paramList of A.exp list
        | paramListOpt of A.exp list
        | fieldCreateOpt
        | fieldCreateList
        | expList
        | expListOpt
        | decList
        | subscript of A.var
        | fieldExp of A.var
        | typedec of A.dec
        | typ
        | typef
        | typeflist
        | fundec
        | vardec of A.dec 
        | dec of  A.dec
        | inter of A.var

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL


%nonassoc THEN
%nonassoc OF DO ELSE 
%nonassoc ASSIGN
%left AND OR
%nonassoc EQ NEQ GE GT LE LT
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar. 
 *)

program	: exp           (exp)

(* can exp produce empty? *)
exp:
        lValue          (lValue)
        | NIL           (A.NilExp)
        | INT           (A.IntExp INT)
        | STRING        (A.StringExp (STRING, STRINGleft))
        | seqExp        ()
        | MINUS exp    %prec UMINUS     ()
        | callExp       (callExp)
        | infixExp      (infixExp)
        | arrCreate     ()
        | recCreate     ()
        | assignment    ()
        | ifThenElse    ()
        | ifThen        ()
        | whileExp      ()
        | forExp        ()
        | BREAK         ()
        | letExp        ()

(********************************************************)
(* Some useful functions for working with different     *)
(* sequences.                                           *)

paramListOpt:
        paramList exp           (paramList::exp)
        |                       ()
paramList:
        paramList exp COMMA     (paramList::exp)
        |                       ()

fieldCreateOpt:
        fieldCreateList ID EQ exp       ()
        |                               ()
fieldCreateList:
        fieldCreateList ID EQ exp COMMA ()
        |                               ()

expListOpt:
        expList exp     ()
        |               ()
expList:
        expList exp SEMICOLON           ()
        |                               ()

decList:
        decList dec             ()
        |                       ()

(*************************************************************)
(* A sequential expression is a sequence of 0 or more   *)
(* expressions enclosed in parentheses and sparated     *)
(* by semi-colons.                                      *)

seqExp:
        LPAREN RPAREN                   ()
        | LPAREN seqExpList exp RPAREN  ()
seqExpList:
        seqExpList exp SEMICOLON        ()
        |                               ()


(********************************************************)
(* The left-side of an assignment statemnt. Can come    *)
(* from a plain ID, the index of an array, or a field   *)
(* specifier, as in a struct.                           *)

lValue: ID              (A.SimpleVar (Symbol.symbol ID, IDleft))
        | inter         (inter)
inter : subscript     (subscript)
        | fieldExp    (fieldExp)
        
subscript:
        ID LBRACK exp RBRACK        (A.SubscriptVar (A.SimpleVar(Symbol.symbol(ID), IDleft), exp, LBRACKleft)) (* doubt about positions*)
        | inter LBRACK exp RBRACK   (A.SubscriptVar (inter, exp, LBRACKleft)) (* doubt about positions*)
fieldExp:
        lValue DOT ID   (A.FieldVar(lValue, Symbol.symbol(ID), DOTleft)) (* doubt about positions*)

(********************************************************)
(* A declaration can be for a type, a variable, or a    *)
(* function. We may expect 0 or more of these at a      *)
(* time.                                                *)

dec:
        typedec         (typedec)
        |vardec          (vardec )
        |fundec          (fundec)

typedec: TYPE ID EQ typ        (A.TypeDec ({name = Symbol.symbol(ID), ty = typ, pos = TYPEleft})) (* doubt about positions*)

typ:    ID                     ()
        | LBRACE typef RBRACE   ()
        | ARRAY OF ID           ()

typef:
        typeflist ID COLON ID           ()
        |                               ()
typeflist:
        typeflist ID COLON ID COMMA     ()
        |                               ()

fundec:
      FUNCTION ID LPAREN typef RPAREN EQ exp            ()
    | FUNCTION ID LPAREN typef RPAREN COLON ID EQ exp   ()

vardec:
      VAR ID ASSIGN exp         ()
    | VAR ID COLON ID ASSIGN exp        ()


(********************************************************)
(* Negation of an expression is multiplication by -1.   *)

 (*  negation:        *)
        (* MINUS exp       () *) 

callExp:
        ID LPAREN paramListOpt RPAREN    (A.CallExp({ func = Symbol.symbol(ID), args = paramListOpt, pos = IDright }))

(********************************************************)
(* These are binary operators.                          *)
infixExp:
        exp PLUS exp    (A.OpExp({left = exp1, oper = A.PlusOp, right = exp2, pos = PLUSleft}))
        | exp MINUS exp    (A.OpExp({left = exp1, oper = A.MinusOp, right = exp2, pos = MINUSleft}))
        | exp TIMES exp    (A.OpExp({left = exp1, oper = A.TimesOp, right = exp2, pos = TIMESleft}))
        | exp DIVIDE exp    (A.OpExp({left = exp1, oper = A.DivideOp, right = exp2, pos = DIVIDEleft}))
        | exp EQ exp    (A.OpExp({left = exp1, oper = A.EqOp, right = exp2, pos = EQleft}))
        | exp NEQ exp    (A.OpExp({left = exp1, oper = A.NeqOp, right = exp2, pos = NEQleft}))
        | exp LT exp    (A.OpExp({left = exp1, oper = A.LtOp, right = exp2, pos = LTleft}))
        | exp LE exp    (A.OpExp({left = exp1, oper = A.LeOp, right = exp2, pos = LEleft}))
        | exp GT exp    (A.OpExp({left = exp1, oper = A.GtOp, right = exp2, pos = GTleft}))
        | exp GE exp    (A.OpExp({left = exp1, oper = A.GeOp, right = exp2, pos = GEleft}))
        | exp AND exp    ()
        | exp OR exp    ()


recCreate:
        ID LBRACE fieldCreateOpt RBRACE    ()

arrCreate:
        ID LBRACK exp RBRACK OF exp     ()

assignment:
        lValue ASSIGN exp   ()


(********************************************************)
(* Branching instructions                               *)

ifThenElse:
        IF exp THEN exp ELSE exp        ()

ifThen:
        IF exp THEN exp                 ()

whileExp:
        WHILE exp DO exp                ()

forExp:
        FOR ID ASSIGN exp TO exp DO exp ()

letExp:
        LET decList IN expListOpt END              ()
