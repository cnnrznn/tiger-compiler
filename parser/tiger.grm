%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN | UMINUS
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

%nonterm  exp
        | program
        | seqExp
        | seqExpList
        | callExp
        | infixExp
        | recCreate
        | ifThenElse
        | ifThen
        | whileExp
        | forExp
        | letExp
        | paramList
        | paramListOpt
        | fieldCreateOpt
        | fieldCreateList
        | expList
        | expListOpt
        | decList
        | subscript
        | fieldExp
        | typedec
        | type
        | typef
        | typeflist
        | fundec
        | vardec
        | dec
        | ssList
        | brackExpBeg
        | brackExpEnd
        | assignOpt
        | dotExp

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%nonassoc OF DO ELSE THEN
%nonassoc ASSIGN
%left AND OR
%nonassoc EQ NEQ GE GT LE LT
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar. 
 *)

program	: exp           ()

(* can exp produce empty? *)
exp:
        brackExpBeg     ()
        | dotExp        ()
        | NIL           ()
        | INT           ()
        | STRING        ()
        | seqExp        ()
        | MINUS exp    %prec UMINUS     ()
        | callExp       ()
        | infixExp      ()
        | recCreate     ()
        | ifThenElse    ()
        | ifThen        ()
        | whileExp      ()
        | forExp        ()
        | BREAK         ()
        | letExp        ()

(********************************************************)
(* Some useful functions for working with different     *)
(* sequences.                                           *)

paramListOpt:
        paramList exp           ()
        |                       ()
paramList:
        paramList exp COMMA     ()
        |                       ()

fieldCreateOpt:
        fieldCreateList ID EQ exp       ()
        |                               ()
fieldCreateList:
        fieldCreateList ID EQ exp COMMA ()
        |                               ()

expListOpt:
        expList exp     ()
        |               ()
expList:
        expList exp SEMICOLON           ()
        |                               ()

decList:
        decList dec             ()
        |                       ()

(*************************************************************)
(* A sequential expression is a sequence of 0 or more   *)
(* expressions enclosed in parentheses and sparated     *)
(* by semi-colons.                                      *)

seqExp:
        LPAREN RPAREN                   ()
        | LPAREN seqExpList exp RPAREN  ()
seqExpList:
        seqExpList exp SEMICOLON        ()
        |                               ()


(********************************************************)
(* The left-side of an assignment statemnt. Can come    *)
(* from a plain ID, the index of an array, or a field   *)
(* specifier, as in a struct.                           *)

dotExp:
        ID DOT ID ssList assignOpt      ()

brackExpBeg:
        ID subscript brackExpEnd        ()

brackExpEnd:
        OF exp                          ()
        | ssList assignOpt              ()

subscript:
        LBRACK exp RBRACK       ()

ssList:
        ssList DOT ID           ()
        | ssList subscript      ()
        |                       ()

assignOpt:
        ASSIGN exp              ()
        |                       ()

(********************************************************)
(* A declaration can be for a type, a variable, or a    *)
(* function. We may expect 0 or more of these at a      *)
(* time.                                                *)

dec:
        typedec         ()
        |vardec          ()
        |fundec          ()

typedec: TYPE ID EQ type        ()

type:    ID                     ()
        | LBRACE typef RBRACE   ()
        | ARRAY OF ID           ()

typef:
        typeflist ID COLON ID           ()
        |                               ()
typeflist:
        typeflist ID COLON ID COMMA     ()
        |                               ()

fundec:
      FUNCTION ID LPAREN typef RPAREN EQ exp            ()
    | FUNCTION ID LPAREN typef RPAREN COLON ID EQ exp   ()

vardec:
      VAR ID ASSIGN exp         ()
    | VAR ID COLON ID ASSIGN exp        ()


(********************************************************)
(* Negation of an expression is multiplication by -1.   *)

 (*  negation:        *)
        (* MINUS exp       () *) 

callExp:
        ID LPAREN paramListOpt RPAREN    ()

(********************************************************)
(* These are binary operators.                          *)
infixExp:
        exp PLUS exp    ()
        | exp MINUS exp    ()
        | exp TIMES exp    ()
        | exp DIVIDE exp    ()
        | exp EQ exp    ()
        | exp NEQ exp    ()
        | exp LT exp    ()
        | exp LE exp    ()
        | exp GT exp    ()
        | exp GE exp    ()
        | exp AND exp    ()
        | exp OR exp    ()


recCreate:
        ID LBRACE fieldCreateOpt RBRACE    ()

(********************************************************)
(* Branching instructions                               *)

ifThenElse:
        IF exp THEN exp ELSE exp        ()

ifThen:
        IF exp THEN exp                 ()

whileExp:
        WHILE exp DO exp                ()

forExp:
        FOR ID ASSIGN exp TO exp DO exp ()

letExp:
        LET decList IN expListOpt END              ()
